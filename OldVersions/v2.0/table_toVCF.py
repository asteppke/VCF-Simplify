#!/home/bin/python

import argparse
import time
import sys


print('\nChecking required modules \n')
''' Purpose of the program: 
    1) Used to merge the haplotype file generated by phase-Extender and phase-Stitcher. 
    2) Merge the table file back to VCF. '''


def main():
    ''' Define required argument for interactive mode program. '''
    parser = argparse.ArgumentParser()


    parser.add_argument("-fromType", required=True,
                        help="Type of the file the VCF is being prepared from. "
                                      "Options: haplotype, table ")
    parser.add_argument("-inFile", required=True,
                        help="Sorted table or haplotype file."
                             "This haplotype file should be obtained from phase-Stitcher, "
                             "phase-Extender. The table file should be in the format "
                             "output by 'VCF-Simplify'; only long format table is supported for now. ")
    parser.add_argument("-outVCF", help="Name of the output VCF file.", required=True)
    parser.add_argument("-vcfHeader", required=True,
                        help="A custom VCF header to add to the VCF file. "
                             "The VCF header should not contain the line with #CHROM .... ")

    """ Additional argument parser only to use if "-fromType" is "table" """
    table_to_vcf_parser = parser.add_argument_group('Extra flags when converting table to VCF.')

    table_to_vcf_parser.add_argument("-GTbase", help="Representation of the GT base is : numeric, IUPAC ", required=False)

    table_to_vcf_parser.add_argument("-samples",
                        help="Name of the samples -> "
                             "comma separated name of the samples that needs to be converted "
                             "to VCF format",
                        default='all', required=False)

    table_to_vcf_parser.add_argument("-formats",
                        help="Name of the FORMAT tags to write -> "
                             "comma separated FORMAT tags name.",
                        default='all', required=False)

    table_to_vcf_parser.add_argument("-infos",
                        help="Name of the INFO tags to write -> "
                             "comma separated INFO tags name. ",
                        default='all', required=False)



    ''' Call globals, input and output argument variable names'''

    ## declare global variables
    global args;
    args = parser.parse_args()


    if args.fromType == 'haplotype':
        print('Converting haplotype file to VCF')
        fnc_haplotype_to_vcf()

    elif args.fromType == 'table':
        print('Converting Table to VCF')
        fnc_table_to_vcf()

    else:
        print('fromType not indicated.')



'''Part C: Function to convert Haplotype To VCF.'''
def fnc_table_to_vcf():
    print('converting Table file to VCF')

    ## declare globals
    global genotype_is
    global begin_time
    global contig_idx
    global pos_idx
    global id_idx
    global ref_idx
    global alt_idx
    global qual_idx
    global filter_idx

    # INFO, FORMAT and SAMPLE don't have index but tags
    global info_tags
    global infos_idx
    global format_tags
    global reduced_format_tags
    global sample_names
    global header_line

    begin_time = time.time()

    '''Assign some input variables. '''
    genotype_is = args.GTbase
    infile = args.inFile
    meta_header = args.vcfHeader
    outfile = args.outVCF
    samples = args.samples
    formats = args.formats
    infos = args.infos


    with open(infile) as hapfile, \
        open(meta_header) as meta_header,\
            open(outfile, 'w+') as vcf_out:

        '''Start reading the haplotype file as generator. This saves memory. '''
        for line in hapfile:

            ## find and set the indexes ...
            # ... of pre-fields, INFO, FORMAT and SAMPLE level information

            ''' Step 01: The very first line of the file is read;
             - to find the variable name and it's index position in the input file.
             - almost all the variable created downstream are "global variables".
             - SAMPLE level information is automatically identified unless explicitly given.
               The sample names is identified using ":" in the column names, so other names
               should not have ":" at all.
             - FORMAT level tags can also be provided as list, or can be mined automatically
               along with SAMPLE by using ":" matching.
             - All the preHeader tags, ie. CHROM  POS  ID  REF  ALT  QUAL  FILTER are reserved and
               updated by matching the names in text header line.
             '''

            # to use the "header" name that have already been taken
              # this will help in finding appropriate "INFO" level tags from the header file
            used_header = []

            if line.startswith('CHROM') \
                    or line.startswith('#CHROM'):
                header_line = line.rstrip('\n').split('\t')

                if 'CHROM' in header_line:
                    contig_idx = header_line.index('CHROM')
                elif '#CHROM' in header_line:
                    contig_idx = header_line.index('#CHROM')
                else:
                    print('CHROM field does not exit. Update your file')
                    break

                # update the taken header "labels"
                used_header += ['CHROM', '#CHROM']

                if 'POS' in header_line :
                    pos_idx = header_line .index('POS')
                else:
                    print('POS field does not exit. Update your file')
                    break

                # update
                used_header += ['POS']

                if 'ID' in header_line :
                    id_idx = header_line .index('ID')
                else:
                    id_idx = None
                used_header += ['ID']

                if 'REF' in header_line :
                    ref_idx = header_line .index('REF')
                else:
                    ref_idx == None
                used_header += ['REF']

                if 'ALT' in header_line :
                    alt_idx = header_line .index('ALT')
                else:
                    alt_idx = None
                used_header += ['ALT']

                if 'QUAL' in header_line :
                    qual_idx = header_line .index('QUAL')
                else:
                    qual_idx = None
                used_header += ['QUAL']

                if 'FILTER' in header_line :
                    filter_idx = header_line .index('FILTER')
                else:
                    filter_idx = None
                used_header += ['FILTER']


                '''SAMPLE names and FORMAT tags are identified using ":" delimiter in the column names. '''
                if samples != 'all':
                    sample_names = samples.split(',')
                elif samples == 'all':
                    sample_names = []
                    for itemy in header_line:
                        if ':' in itemy:
                            sample_names.append(itemy.split(':')[0])
                    sample_names = list(set(sample_names))

                used_header += [x for x in header_line if ':' in x]

                # find the available format tags
                if formats != 'all':
                    format_tags = formats.split(',')

                elif formats == 'all':
                    format_tags = []
                    for names in sample_names:
                        for itemx in header_line :
                            if itemx.startswith(names):
                                format_tags.append(itemx.split(':')[1])

                    format_tags = list(set(format_tags))


                # In the available FORMAT tags, move "GT" field to the beginning.
                if 'GT' in format_tags:
                    format_tags.remove('GT')
                    format_tags.insert(0, 'GT')



                ''' Finally, update the tag names of the "INFO" field '''
                #** Note: Any column names in the header line that is not taken so far is ..
                  # .. considered a "INFO" field.
                remaining_cols = [itx for itx in header_line if itx not in set(used_header)]

                if infos != 'all':
                    info_tags = infos.split(',')
                elif infos == 'all' and len(remaining_cols) > 0:
                    info_tags = remaining_cols
                else:
                    info_tags = None
                    print('INFO tags are not available.')

                # also find the position of the info tags on header line
                infos_idx = []
                if info_tags != None:
                    for inftag in info_tags:
                        infos_idx.append(header_line.index(inftag))
                else:
                    infos_idx = None



                ''' Now, Read the meta header and add it to the output VCF file. '''
                print('\nReading meta header from file "%s" ' %(meta_header.name))

                if meta_header != None:
                    meta_info = meta_header.read()
                else:
                    print('Header with meta information is not provided')
                    break

                # add meta header to the output VCF file
                meta_info += '\t'.join(['#CHROM', 'POS', 'ID', 'REF', 'ALT',
                                         'QUAL', 'FILTER', 'INFO', 'FORMAT']) + '\t'

                # add SAMPLE fields to output VCF file
                meta_info += '\t'.join(sample_names)


                # Finally, write the header part of the output VCF
                vcf_out.write(meta_info + '\n')

                continue
                #break


            '''' Now, extract the required data from each of the remaining lines add to output VCF. '''
            updated_line = table_to_vcf(line)
            vcf_out.write(updated_line)
            vcf_out.write('\n')

        print('Elapsed time : "%s".' %(time.time()-begin_time))



'''Function part of Table to VCF '''
def table_to_vcf(line_in):

    line = line_in.rstrip('\n').split('\t')
    chrom = line[contig_idx]
    pos = line[pos_idx]

    if id_idx is not None:
        ids = line[id_idx]
    else:
        ids = '.'

    ref = line[ref_idx]
    alt = line[alt_idx]

    if qual_idx is not None:
        qual = line[qual_idx]
    else: qual = '.'

    if filter_idx is not None:
        filter = line[filter_idx]
    else: filter = '.'

    # Update "info tags and value". This is little complex
    if info_tags !=None:
        info_ = []
        for ith, itemi in enumerate(info_tags):
            tag_val = '='.join([itemi, line[infos_idx[ith]]])
            info_.append(tag_val)
        info_ = ';'.join(info_)
    elif info_tags is None:
        info_ = '.'

    # write the tags names of the FORMAT column
    if format_tags != None:
        format_ = ':'.join(format_tags)
    else:format_ = '.'


    # update the output line
    line_out = '\t'.join([chrom, pos, ids, ref, alt, qual, filter, info_, format_]) + '\t'

    # Further update the SAMPLE-to-FORMAT values
    # pass the line to another function
    format_to_sample_vals = update_sample_format(line, ref, alt)
    line_out = line_out + format_to_sample_vals

    return line_out

''' Function part of Table to VCF '''
def update_sample_format(line, ref, alt):

    # The "line" variable is passed into this function.
    # The global variables are "genotype_is", "sample_names" and "format_tags"

    # to store updated line
    format_sample_line = []

    all_alleles = [ref] + alt.split(',')

    for namex in sample_names:
        namex_vals = []
        for tagx in format_tags:
            sample_format_tag = namex + ':' + tagx
            sample_format_idx = header_line.index(sample_format_tag)
            sample_format_val = line[sample_format_idx]

            ''' further update the sample:format value if GT in table is as IUPAC base '''
            if tagx == 'GT' and genotype_is == 'IUPAC':
                if sample_format_val == '.' or \
                        sample_format_val == './.' or \
                        sample_format_val == '.|.':
                    continue

                elif '/' in sample_format_val:
                    sample_format_val = sample_format_val.split('/')

                    sample_format_val = [all_alleles.index(sample_format_val[0]),
                                         all_alleles.index(sample_format_val[1])]

                    sample_format_val = '/'.join(str(xth) for xth in sample_format_val)

                elif '|' in sample_format_val:
                    sample_format_val = sample_format_val.split('|')

                    sample_format_val = [all_alleles.index(sample_format_val[0]),
                                         all_alleles.index(sample_format_val[1])]

                    sample_format_val = '|'.join(str(xth) for xth in sample_format_val)

            namex_vals.append(sample_format_val)

        format_sample_line.append(':'.join(namex_vals))

    sample_format_final = '\t'.join(format_sample_line)

    return sample_format_final



'''Part B: Function to convert Haplotype To VCF.'''
def fnc_haplotype_to_vcf():
    print('converting Haplotype file to VCF')
    begin_time = time.time()

    '''Assign some input variables. '''
    infile = args.inFile
    meta_header = args.vcfHeader
    outfile = args.outVCF

    with open(infile) as hapfile, \
        open(meta_header) as meta_header,\
            open(outfile, 'w+') as vcf_out:

        '''Start reading the haplotype file as generator. This saves memory. '''
        for line in hapfile:
            if line.startswith('CHROM') \
                    or line.startswith('#CHROM'):
                header_line = line.rstrip('\n').split('\t')

                if 'CHROM' in header_line:
                    contig_idx = header_line.index('CHROM')
                elif '#CHROM' in header_line:
                    contig_idx = header_line.index('#CHROM')
                else:
                    print('CHROM field does not exit. Update your file')
                    break

                if 'POS' in header_line :
                    pos_idx = header_line .index('POS')
                else:
                    print('POS field does not exit. Update your file')
                    break

                if 'all-alleles' in header_line :
                    all_alleles_idx = header_line .index('all-alleles')
                else:
                    print('"all-alleles" field not available in input file. Update your file')
                    break

                '''Finally find available SAMPLE names and it's FORMAT tags'''
                sample_namex = []
                for itemx in header_line:
                    if ':' in itemx:
                        sample_namex.append(itemx.split(':')[0])
                sample_namex = list(set(sample_namex))

                # assign FORMAT tags - keeping it fixed
                format_tagx = ['GT', 'PI', 'PG', 'PG_al']

                ''' Now, Read the meta header and add it to the output VCF file. '''
                print('\nReading meta header from file "%s" ' % (meta_header.name))
                if meta_header != None:
                    meta_info = meta_header.read().rstrip('\n')
                    meta_info += '\n'
                else:
                    print('Header with meta information is not provided')
                    break

                # add meta header to the output VCF file
                meta_info += '\t'.join(['#CHROM', 'POS', 'ID', 'REF', 'ALT',
                                        'QUAL', 'FILTER', 'INFO', 'FORMAT']) + '\t'

                # add SAMPLE fields to output VCF file
                meta_info += '\t'.join(sample_namex)

                # Finally, write the header part of the output VCF
                vcf_out.write(meta_info + '\n')

                continue

            '''' Now, extract the required data from each of the remaining lines add to output VCF. '''
            updated_line = haplotype_to_vcf(
                line, header_line, all_alleles_idx, sample_namex, format_tagx)
            vcf_out.write(updated_line)
            vcf_out.write('\n')

        print('Elapsed time : "%s".' % (time.time() - begin_time))


''' Part B: Function part of Haplotype To VCF '''
def haplotype_to_vcf(line, header_line, all_alleles_idx, sample_namex, format_tagx):

    line = line.rstrip('\n').split('\t')

    contig = line[0]
    pos = line[1]
    id = '.'

    all_alleles = line[all_alleles_idx].split(',')
    ref = all_alleles[0]
    alt = ','.join(all_alleles[1:])
    qual = '.'
    filter_ = '.'
    info_ = '.'
    format_ = ':'.join(format_tagx)

    line_out = '\t'.join([contig, pos, id, ref, alt, qual, filter_, info_, format_])

    # Now, update SAMPLE:FORMAT values
    # Haplotype file exclusively will have PI and PG_al

    format_sample_values = []
    for namex in sample_namex:
        sample_PG_al = namex + ':PG_al'
        sample_PG_al_idx = header_line.index(sample_PG_al)
        sample_PG_al_value = line[sample_PG_al_idx]

        sample_PI_idx = header_line.index(namex + ':PI')
        sample_PI_value = line[sample_PI_idx]

        # to store the values for GT and PG tags
        sample_GT_value = '.'
        sample_PG_value = '.'

        if sample_PG_al_value == '.' \
                or sample_PG_al_value == './.' \
                or sample_PG_al_value == '.|.':
            sample_GT_value = '.'

        elif '/' in sample_PG_al_value:
            sample_GT_value = sample_PG_al_value.split('/')
            sample_GT_value = [all_alleles.index(sample_GT_value[0]),
                               all_alleles.index(sample_GT_value[1])]
            sample_GT_value = '/'.join(str(sth) for sth in sample_GT_value)
            sample_PG_value = sample_GT_value

        elif '|' in sample_PG_al_value:
            sample_GT_value = sample_PG_al_value.split('|')
            sample_GT_value = [all_alleles.index(sample_GT_value[0]),
                               all_alleles.index(sample_GT_value[1])]
            sample_GT_value = '|'.join(str(sth) for sth in sample_GT_value)
            sample_PG_value = sample_GT_value

        format_sample_values.append(
            ':'.join([sample_GT_value, sample_PI_value, sample_PG_value, sample_PG_al_value]))

    line_out += '\t' + '\t'.join(format_sample_values)

    return line_out


if __name__ == '__main__':
    main()